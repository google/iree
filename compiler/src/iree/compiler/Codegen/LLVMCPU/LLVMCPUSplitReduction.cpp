// Copyright 2023 The IREE Authors
//
// Licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include "iree/compiler/Codegen/PassDetail.h"
#include "iree/compiler/Codegen/Passes.h"
#include "mlir/Dialect/Affine/IR/AffineOps.h"
#include "mlir/Dialect/Linalg/IR/Linalg.h"
#include "mlir/Dialect/Linalg/Transforms/Transforms.h"
#include "mlir/Dialect/Linalg/Utils/Utils.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/Dialect/MemRef/Transforms/Passes.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/Dialect/SCF/Transforms/TileUsingInterface.h"
#include "mlir/Dialect/SCF/Transforms/Transforms.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Transforms/GreedyPatternRewriteDriver.h"

#define DEBUG_TYPE "iree-llvmcpu-split-reduction"

namespace mlir {
namespace iree_compiler {
namespace {

class LLVMCPUSplitReductionPass
    : public LLVMCPUSplitReductionBase<LLVMCPUSplitReductionPass> {
 public:
  LLVMCPUSplitReductionPass(bool fpReductionReordering)
      : fpReductionReordering(fpReductionReordering) {}

  void getDependentDialects(DialectRegistry &registry) const override {
    registry.insert<linalg::LinalgDialect, scf::SCFDialect>();
  }
  void runOnOperation() override;

 private:
  bool fpReductionReordering = false;
};

void LLVMCPUSplitReductionPass::runOnOperation() {
  MLIRContext *context = &getContext();
  auto funcOp = getOperation();

  SmallVector<Operation *> computeOps = getComputeOps(funcOp);
  FailureOr<IREE::Codegen::LoweringConfigAttr> maybeLoweringConfig =
      getLoweringConfig(computeOps);
  if (failed(maybeLoweringConfig)) {
    LLVM_DEBUG(llvm::dbgs()
               << "can't find lowering_config, skip SplitReduction");
    return;
  }
  int64_t reductionRatio =
      maybeLoweringConfig.value().getTileSizeVals().back().back();

  SmallVector<linalg::GenericOp> candidates;
  funcOp.walk([&](linalg::GenericOp op) { candidates.push_back(op); });
  for (auto genericOp : candidates) {
    LLVM_DEBUG(llvm::dbgs() << "candidate: " << genericOp << "\n");
    linalg::LinalgOp op = cast<linalg::LinalgOp>(genericOp.getOperation());

    if (!op.hasTensorSemantics() || op.getNumReductionLoops() != 1 ||
        op.getNumDpsInits() != 1 || !op.hasOnlyProjectedPermutations() ||
        op.getNumDpsInputs() != 1) {
      LLVM_DEBUG(llvm::dbgs() << "precondition not meet\n");
      continue;
    }

    auto elemType =
        getElementTypeOrSelf(op.getDpsInputOperand(0)->get().getType());
    if (!(fpReductionReordering || elemType.isIntOrIndex())) {
      LLVM_DEBUG(
          llvm::dbgs()
          << "skipped because reduction reordering on FP is not enabled.\n");
      continue;
    }

    IRRewriter rewriter(context);
    IRRewriter::InsertionGuard g(rewriter);
    rewriter.setInsertionPointAfter(op);

    SmallVector<unsigned> dims;
    op.getReductionDims(dims);
    AffineMap map = op.getMatchingIndexingMap(op.getDpsInputOperand(0));
    unsigned lastIdx = map.getNumResults() - 1;
    unsigned lastDim = map.getDimPosition(lastIdx);
    if (lastDim != dims[0]) {
      LLVM_DEBUG(
          llvm::dbgs()
          << "innermost dimension of the input operand is not reduction\n");
      continue;
    }

    linalg::ControlSplitReductionFn fn = [reductionRatio,
                                          lastIdx](linalg::LinalgOp) {
      return linalg::SplitReductionOptions{reductionRatio, lastIdx,
                                           /*innerParallel=*/true};
    };

    auto numLoops = op.getNumLoops();

    // 1) Tile to extract a single vector-length array.
    SmallVector<int64_t> tileSizesSVFirst(numLoops, 1);
    tileSizesSVFirst[numLoops - 1] = 0;
    auto options = scf::SCFTilingOptions().setTileSizes(tileSizesSVFirst);
    FailureOr<scf::SCFTilingResult> tileResFirst = scf::tileUsingSCFForOp(
        rewriter, cast<TilingInterface>(op.getOperation()), options);
    if (failed(tileResFirst)) {
      LLVM_DEBUG(llvm::dbgs() << "failed on step 1 (SCFTiling)\n");
      return signalPassFailure();
    }
    rewriter.replaceOp(op, tileResFirst->replacements);

    // 2) Apply splitReduction on the single vector-length array.
    // splitReduction already replaces the op.
    FailureOr<linalg::SplitReductionResult> splitRes =
        splitReduction(rewriter, tileResFirst->tiledOps.back(), fn);
    if (failed(splitRes)) {
      LLVM_DEBUG(llvm::dbgs() << "failed on step 2 (SplitReduction)\n");
      continue;
    }

    // 3) Tile the first op generated by splitReduction with tile size of 1,
    // to essentially create a reduction loop. Note that
    // splitRes->splitLinalgOp.getNumLoops() = numLoops + 1.
    SmallVector<int64_t> tileSizesSV(splitRes->splitLinalgOp.getNumLoops(), 0);
    // The reduction happens only in the penultimate dimension, which we now
    // tile.
    tileSizesSV[numLoops - 1] = 1;
    options = scf::SCFTilingOptions().setTileSizes(tileSizesSV);
    FailureOr<scf::SCFTilingResult> tileRes = scf::tileUsingSCFForOp(
        rewriter, cast<TilingInterface>(splitRes->splitLinalgOp.getOperation()),
        options);
    if (failed(tileRes)) {
      LLVM_DEBUG(llvm::dbgs() << "failed on step 3 (SCFTiling)\n");
      return signalPassFailure();
    }
    rewriter.replaceOp(splitRes->splitLinalgOp, tileRes->replacements);
  }
}
}  // namespace

std::unique_ptr<OperationPass<func::FuncOp>> createLLVMCPUSplitReductionPass(
    const bool enableFpReductionReordering) {
  return std::make_unique<LLVMCPUSplitReductionPass>(
      enableFpReductionReordering);
}
}  // namespace iree_compiler
}  // namespace mlir
