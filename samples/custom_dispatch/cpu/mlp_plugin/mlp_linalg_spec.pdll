#include "mlir/Dialect/Linalg/IR/LinalgOps.td"
#include "mlir/Dialect/Arith/IR/ArithOps.td"
#include "mlir/Dialect/Func/IR/FuncOps.td"
#include "mlir/Dialect/Tensor/IR/TensorOps.td"


// Native rewrite "rewriteAsFlowDispatch"
Rewrite rewriteAsFlowDispatch(op : Op,  inputs : ValueRange, repl_vals : ValueRange, repl_dims : ValueRange, other : ValueRange) -> Op;


Pattern mlp with benefit(1) {
  let LhsTy : Type;
  let RhsTy : Type;
  let MatMulTy : Type;
  let zeroVal = op<arith.constant> { value = attr<"0.0 : f32"> };
  let fillOp = op<linalg.fill> (zeroVal.0, empty : Value) -> (MatMulTy);
  let matMulOp = op<linalg.matmul> (lhs : Value<LhsTy>, rhs : Value<RhsTy>, fillOp.0) -> (MatMulTy);

  rewrite matMulOp with {
    let IntTy = type<"i32">;
    let IndexType = type<"index">;
    let BoolTy = type<"i1">;
    let constZero = op<arith.constant> { value = attr<"0 : i32"> } -> (BoolTy);
    let constOne = op<arith.constant> { value = attr<"1 : i32"> } -> (BoolTy);
    let m = op<tensor.dim>(lhs, constZero) -> (IndexType);
    let n = op<tensor.dim>(rhs, constOne)  -> (IndexType);
    let k = op<tensor.dim>(lhs, constOne) -> (IndexType);
    let m_cast = op<arith.index_cast>(m)  -> (IntTy);
    let n_cast = op<arith.index_cast>(n) -> (IntTy);
    let k_cast = op<arith.index_cast>(k) -> (IntTy);



    let doRelu = op<arith.constant> { value = attr<"0 : i1"> };
    let inputs = (lhs, rhs);
    let repl_vals = (matMulOp.0 );
    let repl_dims = (m.0, n.0);
    let other = (m_cast.0, n_cast.0, k_cast.0, doRelu.0);
    rewriteAsFlowDispatch(matMulOp, inputs, repl_vals, repl_dims, other);
  };
}
