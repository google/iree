// declare native rewrite called "rewriteAsFlowDispatch". This will
// rewrite the matched op with an external function called fn_name 
// ("mlp_external" defined in mlp_plugin.c)
Rewrite rewriteAsFlowDispatch(
        op : Op, fn_name : Attr, 
        inputs : ValueRange, 
        repl_vals : ValueRange, 
        repl_dims : ValueRange, 
        other : ValueRange);


Pattern mlp_linalg with benefit(1) {
  // Types. These constrain the types of the various arguments and
  // results and ensure that these values are properly matched
  let LhsTy = type<"tensor<?x?xf32>">;
  let RhsTy = type<"tensor<?x?xf32>">;
  let MatMulTy = type<"tensor<?x?xf32>">;
  let IntTy = type<"i32">;
  let IndexTy = type<"index">;
  let BoolTy = type<"i1">;
  let FloatTy = type<"f32">;

  // We are trying to find 3 ops (arith.constant, linalg.fill, linalg.matmul)
  // which form the following DAG:
  // +----------------+                          
  // | arith.constant |                          
  // | value = 0.0:f32|                          
  // +-+--------------+                          
  //   |                                         
  //   | FloatTy (f32)                           
  //   v                                         
  // +----------------+                          
  // |  linalg.fill   | <-- empty: any type      
  // +-+--------------+                          
  //   |                                         
  //   | FloatTy (f32)                           
  //   v                                         
  // +----------------+                          
  // |                | <--  lhs: tensor<?x?xf32>
  // |  linalg.matmul |                          
  // |                | <--  rhs: tensor<?x?xf32>
  // +----------------+                          
  //                                             
  let zeroVal = op<arith.constant> { value = attr<"0.000000e+00 : f32"> } -> (FloatTy);
  let fillOp = op<linalg.fill> (zeroVal.0, empty : Value) -> (MatMulTy);
  let matMulOp = op<linalg.matmul> 
                (lhs : Value<LhsTy>, rhs : Value<RhsTy>, fillOp.0) -> (MatMulTy);

  rewrite matMulOp with {
    let zeroOp = op<arith.constant> { value = attr<"0 : index"> } 
      -> (IndexTy);
    let oneOp = op<arith.constant> { value = attr<"1 : index"> } 
      -> (IndexTy);
    let m = op<tensor.dim>(lhs, zeroOp) -> (IndexTy);
    let n = op<tensor.dim>(rhs, oneOp)  -> (IndexTy);
    let k = op<tensor.dim>(lhs, oneOp); 
    let m_cast = op<arith.index_cast>(m)  -> (IntTy);
    let n_cast = op<arith.index_cast>(n) -> (IntTy);
    let k_cast = op<arith.index_cast>(k) -> (IntTy);



    let doRelu = op<arith.constant> { value = attr<"0 : i1">};
    let inputs = (lhs, rhs);
    let repl_vals = (matMulOp.0 );
    let repl_dims = (m.0, n.0);
    let other = (m_cast.0, n_cast.0, k_cast.0, doRelu.0);

    // rewrite to call the external funciton "mlp_external"
    rewriteAsFlowDispatch(
      matMulOp, attr<"\"mlp_external\"">, 
      inputs, repl_vals, 
      repl_dims, other);
  };
}
